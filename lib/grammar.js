/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#19ce18f8cc0bb0def947bcdbc1a08a138868bca5
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { interpolateArray as _interpolateArray, interpolateArrayChildren as _interpolateArrayChildren, interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
let _initProto, _ArrayDecs, _ObjectDecs, _TupleDecs, _BooleanDecs, _NullDecs, _IdentifierDecs, _IntegerDecs, _InfinityDecs, _PunctuatorDecs, _KeywordDecs, _AnyDecs;
import { CoveredBy, Node, InjectFrom } from '@bablr/helpers/decorators';
import * as Space from '@bablr/language-en-blank-space';
import * as productions from '@bablr/helpers/productions';
export const canonicalURL = 'https://bablr.org/languages/core/en/bablr-vm-instruction';
export const dependencies = {
  Space
};
export function* eatMatchTrivia() {
  if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
    verb: _t.s_node(_l.Instruction, "Identifier", "match"),
    arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
      openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
      values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
        alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
          elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
            elements: [_t.node(_l.Regex, "Character", [_t.lit(" ")], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\t")], {}, {
              cooked: "\t"
            }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\n")], {}, {
              cooked: "\n"
            }))], {}, {})],
            closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
          }, {
            negate: false
          })]
        }, {})],
        closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
      }, {})],
      closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
    }, {})
  }, {})) {
    return yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`triviaToken`, _t.ref`tokenToken`], {
              triviaToken: _t.s_i_node(_l.CSTML, "Punctuator", "#"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            language: _t.s_node(_l.Spamex, "Identifier", "Space"),
            namespaceSeparatorToken: _t.s_i_node(_l.Spamex, "Punctuator", ":"),
            type: _t.s_node(_l.Spamex, "Identifier", "Space"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  return null;
}
export const grammar = class BABLRVMInstructionGrammar {
  static {
    [_initProto] = _applyDecs(this, [[Node, 2, "Call"], [_ArrayDecs, 2, "Array"], [_ObjectDecs, 2, "Object"], [Node, 2, "Property"], [_TupleDecs, 2, "Tuple"], [_BooleanDecs, 2, "Boolean"], [_NullDecs, 2, "Null"], [_IdentifierDecs, 2, "Identifier"], [Node, 2, "UnsignedInteger"], [_IntegerDecs, 2, "Integer"], [Node, 2, "Digit"], [_InfinityDecs, 2, "Infinity"], [_PunctuatorDecs, 2, "Punctuator"], [_KeywordDecs, 2, "Keyword"], [_AnyDecs, 2, "Any"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_ArrayDecs = [CoveredBy('Expression'), Node], _ObjectDecs = [CoveredBy('Expression'), Node], _TupleDecs = [CoveredBy('Expression'), Node], _BooleanDecs = [CoveredBy('Expression'), Node], _NullDecs = [CoveredBy('Expression'), Node], _IdentifierDecs = [CoveredBy('Expression'), Node], _IntegerDecs = [CoveredBy('Number'), Node], _InfinityDecs = [CoveredBy('Number'), Node], _PunctuatorDecs = [Node, InjectFrom(productions)], _KeywordDecs = [Node, InjectFrom(productions)], _AnyDecs = InjectFrom(productions), "Call")]() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("callee")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Tuple"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("arguments")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Expression() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Array"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("[")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Object"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("{")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Tuple"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("(")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Boolean"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
                }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("f")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("l")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
                }, {})],
                separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Null"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("null")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                    element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                      openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                      elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                        min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                        rangeToken: _t.s_i_node(_l.Regex, "Punctuator", "-"),
                        max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                      }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                        min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                        rangeToken: _t.s_i_node(_l.Regex, "Punctuator", "-"),
                        max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                      }, {})],
                      closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                    }, {
                      negate: false
                    }),
                    value: _t.s_i_node(_l.Regex, "Keyword", "+")
                  }, {
                    min: 1,
                    max: Infinity,
                    greedy: true
                  })]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Number"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                      escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                      value: _t.s_i_node(_l.Regex, "Keyword", "d")
                    }, {})],
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                    element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                      openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                      elements: [_t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {})],
                      closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                    }, {
                      negate: false
                    }),
                    value: _t.s_i_node(_l.Regex, "Keyword", "?")
                  }, {
                    min: 0,
                    max: 1,
                    greedy: true
                  }), _t.node(_l.Regex, "Character", [_t.lit("I")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("n")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("f")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("i")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("n")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("i")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("y")], {}, {})]
                }, {})],
                separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Array() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("[")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("]")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let sp = yield* eatMatchTrivia();
    let first = true;
    while ((first || sp) && (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`, _t.ref`flags`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "AnyCharacterSet", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Regex, "Keyword", ".")
            }, {})]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          flags: _t.node(_l.Regex, "Flags", [_t.ref`tokens[]`, _t.arr(), _t.ref`tokens[]`], {
            tokens: [_t.s_i_node(_l.Regex, "Keyword", "y")]
          }, {
            global: false,
            ignoreCase: false,
            multiline: false,
            dotAll: false,
            unicode: false,
            sticky: true
          })
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}))) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Expression"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("elements[]")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      sp = yield* eatMatchTrivia();
      first = false;
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("]")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Object() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("{")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let sp = yield* eatMatchTrivia();
    let first = true;
    while ((first || sp) && (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`, _t.ref`flags`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "AnyCharacterSet", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Regex, "Keyword", ".")
            }, {})]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          flags: _t.node(_l.Regex, "Flags", [_t.ref`tokens[]`, _t.arr(), _t.ref`tokens[]`], {
            tokens: [_t.s_i_node(_l.Regex, "Keyword", "y")]
          }, {
            global: false,
            ignoreCase: false,
            multiline: false,
            dotAll: false,
            unicode: false,
            sticky: true
          })
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}))) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Property"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("properties[]")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      sp = yield* eatMatchTrivia();
      first = false;
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Property() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("key")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(":")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("mapToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Expression"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Tuple() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("(")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let sp = yield* eatMatchTrivia();
    let first = true;
    while ((first || sp) && (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`, _t.ref`flags`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "AnyCharacterSet", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Regex, "Keyword", ".")
            }, {})]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          flags: _t.node(_l.Regex, "Flags", [_t.ref`tokens[]`, _t.arr(), _t.ref`tokens[]`], {
            tokens: [_t.s_i_node(_l.Regex, "Keyword", "y")]
          }, {
            global: false,
            ignoreCase: false,
            multiline: false,
            dotAll: false,
            unicode: false,
            sticky: true
          })
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}))) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Expression"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("values[]")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      sp = yield* eatMatchTrivia();
      first = false;
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Boolean() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
              }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.lit("f")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("l")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
              }, {})],
              separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Null() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("null")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Identifier() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                  min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                  rangeToken: _t.s_i_node(_l.Regex, "Punctuator", "-"),
                  max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                  min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                  rangeToken: _t.s_i_node(_l.Regex, "Punctuator", "-"),
                  max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {
                negate: false
              }),
              value: _t.s_i_node(_l.Regex, "Keyword", "+")
            }, {
              min: 1,
              max: Infinity,
              greedy: true
            })]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Number() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Integer"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                    element: _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {}),
                    value: _t.s_i_node(_l.Regex, "Keyword", "?")
                  }, {
                    min: 0,
                    max: 1,
                    greedy: true
                  }), _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                    escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                    value: _t.s_i_node(_l.Regex, "Keyword", "d")
                  }, {})]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Infinity"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {})],
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  }), _t.node(_l.Regex, "Character", [_t.lit("I")], {}, {})]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *UnsignedInteger() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Digits"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("digits[]")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Integer() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("-")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negativeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Digits"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("digits[]")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Digits() {
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Digit"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                  escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                  value: _t.s_i_node(_l.Regex, "Keyword", "d")
                }, {})]
              }, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}));
  }
  *Digit() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
              escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
              value: _t.s_i_node(_l.Regex, "Keyword", "d")
            }, {})]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Infinity() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {})],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                })]
              }, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("signToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("Infinity")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Punctuator() {}
  *Keyword() {}
  *Any() {}
};