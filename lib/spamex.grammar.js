/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./spamex.grammar.macro.js#50b55ad80fe83916d9ab600b27e0c4ae14fe1399
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import { interpolateArray as _interpolateArray, interpolateFragmentChildren as _interpolateFragmentChildren, interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
import * as Spamex from '@bablr/language-en-spamex';
import * as Instruction from './grammar.js';
export const canonicalURL = 'https://bablr.org/languages/core/en/bablr-vm-spamex-instruction';
export const dependencies = {
  ...Instruction.dependencies,
  Spamex
};
export const grammar = class BABLRVMSpamexInstructionGrammar extends Instruction.grammar {
  *Expression() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [10, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`], [_t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "Spamex")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "Matcher"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("<")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("/")], {}, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                })]
              }, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      // done
    } else {
      yield* super.Expression();
    }
  }
};